<!DOCTYPE html>

<!-- Author Oliver Morgan -->

<html lang="cs">
<head>
    <!--fonts-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@200&display=swap" rel="stylesheet">

    <meta charset="UTF-8">

    <title>Životopis - Oliver Morgan</title>
    <style>
        *{
            margin: 0;
            padding: 0;
            color: ghostwhite;
            font-family: monospace;
        }
        body{
            background: rgb(10,5,20);
        }
        header{
            position: relative;
            display: flex;
            width: 100%;
            height: 75%;
            background: rgb(5,0,15);
            background: linear-gradient(180deg, rgba(15,10,45,1) 0%, rgba(5,0,15,1) 100%);
            align-items: center;
            overflow: hidden;
            box-shadow: 0 2px 6px rgb(5,0,15)
        }
        header h1{
            position: relative;
            z-index: 2;
            left: 50%;
            transform: translate(-50%,0%);
            color: ghostwhite;
            font-family: monospace;
            font-size: 6vw;
        }
        header canvas{
            position: absolute;
        }
        div{
            position: relative;
            z-index: 2;
            display: inline-block;
            background: rgb(5,5,5);
            padding: 50px;
            margin: 50px;
            border-radius: 5px;
            box-shadow: 1px 1px 4px rgb(40,0,150);
            transition: 0.3s all linear;

        }
        div:hover{
            box-shadow: 2px 2px 5px rgb(140,40,250);
        }

        div:nth-child(3){
            box-shadow: 1px 1px 4px rgb(140,0,150);
        }
        div:nth-child(3):hover{
            box-shadow: 2px 2px 5px rgb(240,10,250);
        }
        div:nth-child(4){
            box-shadow: 1px 1px 4px rgb(140,80,50);
        }
        div:nth-child(4):hover{
            box-shadow: 2px 2px 5px rgb(240,10,150);
        }
        div:nth-child(5){
            box-shadow: 1px 1px 4px rgb(10,200,100);
        }
        div:nth-child(5):hover{
            box-shadow: 2px 2px 5px rgb(40,250,120);
        }
        div:nth-child(6){
            box-shadow: 1px 1px 4px rgb(100,80,200);
        }
        div:nth-child(6):hover{
            box-shadow: 2px 2px 5px rgb(70,100,250);
        }

        div h1{
            font-size: 40px;
            padding-bottom: 25px;
        }
        div h3{
            font-size: 30px;
            padding: 5px;

        }
        div h4{
            font-size: 30px;

        }
        div p{
            font-size: 28px;
        }

        #canvas2{
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
            width: 100%;
            height: 100%;
        }
    </style>
  </head>
    <body>
        <header>
            <h1>Oliver Morgan</h1>
            <canvas id="canvas1"></canvas>
        </header>


        <div style="padding: 20px">
            <img src="https://files.fm/thumb_show.php?i=zej3erx7h" alt="Jejda, něco se pokazilo">
        </div>


        <div>
            <h1>INFORMACE</h1>
            <h3>tel: (+420) 776 100 661 <br>
                email: <span style="padding-right: 50px">oliver.parker.morgan@gmail.com</span><br>
                Github: <a href="https://github.com/atOliverParkerMorgan">atOliverParkerMorgan</a> <br>
                web: <a href="https://olivermorgan.pythonanywhere.com/projects">Moje projekty</a><br>
                <br>
                Narozen 2003 v Praze
            </h3>


        </div>


        <div>

            <h1>PROGRAMOVÁNÍ</h1>
            <br>
            <br>
            <br>
            <br>

            <h4>Java</h4><br>
                <p>
                — Začal jsem programovat v osmé třídě. Od té doby jsem stihl vytvořit řadu projektů v mnoho různých jazycích (viz moje projekty a github).
                Převážně programuji v Javě, ve které jsem mimo jiné naprogramoval:
                <a href="https://github.com/atOliverParkerMorgan/Chess_AI">šachy s umělou inteligencí</a>,
                <a href="https://github.com/atOliverParkerMorgan/BookHunter-mobile">BookHunter-mobile</a>,
                <a href="https://github.com/atOliverParkerMorgan/Tetris">tetris s umělou inteligencí</a>,
                <a href="https://github.com/atOliverParkerMorgan/Checkers">Dáma</a>.
                </p>
                <br>
                <br>
                <br>
                <br>
                <h4>Python</h4><br>
                <p>
                — Dalé velmi dobře umím pracovat v Pythonu, s kterým jsem sestrojil např:
                <a href="https://github.com/atOliverParkerMorgan/Snake_nn">snejka ovladného umělou inteligencí</a>
                — tento projekt využívá neurální sítě a genetický algoritmus;
                <a href="https://github.com/atOliverParkerMorgan/maze">luštič bludiště</a> - prostředí,
                ve kterém lze graficky zobrazit algoritmy A*, Dijsktra, DFS.

                Pomocí Python knihovny Django, jsem vytvořil několik webových eshopů a stránek:
                <a href="https://www.morganbooks.eu/">morganbooks</a> - eshop mého otce;
                <a href="https://www.limetka.art/">limetka.art</a> - eshop na zakázku;
                <a href="https://olivermorgan.pythonanywhere.com/projects">moje životopisná stránka</a>.
                Dokážu naprogramovat eshop či webovou stránku od počátku až do konce. Jsem schopný tvořit backend i frontend.
                </p>
                <br>
                <br>
                <br>
                <br>
                <h4>Javascript</h4><br>
                <p>
                — Vyznám se i v Javascriptu, díky kterému zákazníkům, kteří naštěvují mé eshopy, zajišťuji skvělý user experience.
                </p>
                <br>
                <br>
                <br>
                <br>
                <h4>SQL</h4><br>
                <p>
                — Mám mnoho zkušeností s databázemi, které jsem využíval pro své webové aplikace a
                android aplikace. S projektem
                <a href="https://github.com/atOliverParkerMorgan/SmartBag">Smartbag</a>,
                který využívá API bakalářů a slouží studentům k přípravě tašky do školy, jsem vyhrál pražské kolo SOČ. Umím pracovat s MySQL a sqlite
                </p>
                <br>
                <br>
                <p> — Programuji průměrně hodinu denně </p>


        </div>

        <div>
            <h1>DOVEDNOSTI</h1>
            <p>Jsem třetím rokem skautským vedoucím v oddílu <a href="https://8sipka.pythonanywhere.com/">Šipka</a>
                (webovky jsem naprogramoval), mám řadu zkušeností s prací v týmu. Jsem velmi zodpovědný a pracovitý.</p>
        </div>
        <div>
            <h1>STUDIUM</h1>
            <p>ZŠ Bílá; <br>
                dosud Gymnázium Arabská, obor programování</p>
        </div>

        <div>
            <h1>JAZYKY</h1>
            <p>Jsem biligvní v češtině a angličtině.
                <br>
                Učím se šest let francouzštinu.</p>
        </div>


        <canvas id="canvas2"></canvas>
        <script>
            /*
            Author Oliver Morgan
            my CV is a part of my CV :)
            */


            // get canvas elements
            const canvasWithBallsElement = document.getElementById("canvas1");
            const canvasWithDotElement = document.getElementById("canvas2");

            // get to 2d canvas
            const canvasWithBalls = canvasWithBallsElement.getContext("2d");
            const canvasWithDot = canvasWithDotElement.getContext("2d");

            // set width and height =>  canvasWithBallsElement overlaps canvasWithDotElement
            canvasWithBallsElement.width = window.innerWidth;
            canvasWithBallsElement.height = window.innerHeight
            canvasWithDotElement.width = window.innerWidth;
            canvasWithDotElement.height = window.innerHeight;
            window.addEventListener("resize",function(){
                // reset size width and height on resize
                canvasWithBallsElement.width = window.innerWidth;
                canvasWithBallsElement.height = window.innerHeight;
                canvasWithDotElement.width = window.innerWidth;
                canvasWithDotElement.height = window.innerHeight;

                // reset dots
                Dot.init();
            });

            // mouse object
            const mouse = {
                x: undefined,
                y: undefined
            };

            // update mouse cord on mousemove
            window.addEventListener("mousemove",function(e){
                    mouse.x = e.clientX;
                    mouse.y = e.clientY;
            });



            window.addEventListener("mousedown",function(e){
               // get the position of a dot in 2d-list Dot.allDots from mouse cords
               let x = Dot.getIndexX(e.clientX);
               let y = Dot.getIndexY(e.clientY);

               // start wave from the dot that was selected
               Dot.startWave(x, y)
            });



            class Ball{
                // contains all of the balls that are being displayed
                static allBalls = [];

                // set true if you want to hide all balls
                static hide = false

                constructor(x, y, size, color, weight){
                    this.x = x;
                    this.y = y;
                    this.size = size;
                    this.color = color;
                    this.weight = weight;
                }

                static init(){
                    Ball.allBalls = [];

                    // initialize all balls by creating 200 balls with random positions and sized
                    for(let i = 0; i < 200; i++){
                        const x = Math.random() * canvasWithBallsElement.width;
                        const y = Math.random() * canvasWithBallsElement.height;
                        const size = Math.random() * 10 + 2;

                        const color = "ghostwhite";

                        // weight is used to calculate bounce physics
                        const weight = 1;

                        Ball.allBalls.push(new Ball(x,y,size,color,weight));
                    }
                }

                draw(){

                    if (Ball.hide) {
                        return;
                    }

                    // beginPath is used to redraw colors
                    canvasWithBalls.beginPath();
                    // draw ball
                    canvasWithBalls.arc(this.x, this.y, this.size, Math.PI * 2, 0);
                    // set color
                    canvasWithBalls.fillStyle = this.color;
                    // fill shape with color
                    canvasWithBalls.fill();
                }
                update(){
                    if (Ball.hide) {
                        return;
                    }

                    // bounce logic

                    // make ball smaller
                    this.size -= 0.05;
                    if(this.size < 0){
                        // if is too small create a new ball that is based on mouseX position
                        this.x = mouse.x;
                        this.y = canvasWithBallsElement.height/2
                        this.size = Math.random()*10 + 2;
                        this.weight = Math.random() * 1.5;
                    }

                    // gravity logic
                    this.y += this.weight;
                    this.weight += 0.2;

                    if(this.y > canvasWithBallsElement.height - this.size){
                        // revers the direction if the ball "touches" the ground
                        this.weight *= -1;
                    }
                }
            }

            const SMALL_SIZE = 5
            const BIG_SIZE = 15
            const DOT_DISTANCE = 30
            const NUMBER_OF_UPDATES = 5;

            class Dot {
                // contains all dots
                static allDots = [[]];

                // used to working with dots in wave
                static nodesToShow = [];

                // are all dots currently big or small
                // is true because Dot.startWaves() reverses value
                static nodesAreBig = true;

                // is a wave currently being solved
                static isSolving = false;


                constructor(x, y, color) {
                    this.x = x
                    this.y = y
                    this.color = color
                    this.size = SMALL_SIZE

                }

                static init() {
                    let line = []
                    Dot.allDots = [];

                    // distribute dots evenly across canvas using DOT_DISTANCE
                    // and save into 2d list Dot.allDots

                    for (let y = 0; y < canvasWithDotElement.height; y+=DOT_DISTANCE) {
                        for (let x = DOT_DISTANCE; x < canvasWithDotElement.width; x+=DOT_DISTANCE) {
                            line.push(new Dot(x, y, "ghostwhite"));
                        }
                        Dot.allDots.push(line)
                        line = [];
                    }

                }

                draw() {
                    canvasWithDot.beginPath();
                    canvasWithDot.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    canvasWithDot.fillStyle = this.color;
                    canvasWithDot.fill();

                }
                static startWave(x, y){
                    if(!Dot.isSolving) {
                        Dot.nodesAreBig = !Dot.nodesAreBig;
                        Dot.isSolving = true;

                        // set starting node
                        Dot.startingNode = Dot.allDots[y][x];
                        Dot.nodesToShow.unshift(Dot.startingNode);
                        Dot.startingNode.reverseSize();
                    }

                }

                 static showWave(){
                    if(Dot.nodesToShow.length < 1){

                        Dot.isSolving = false;
                        return
                    }

                    let currentNode = Dot.nodesToShow.shift();
                    let neighbours = currentNode.getNeighbours();

                    for (let i = 0; i < neighbours.length; i++) {
                        Dot.nodesToShow.push(neighbours[i]);
                        neighbours[i].reverseSize();
                    }

                }

                makeBigger(){
                    this.size = BIG_SIZE;
                }
                makeSmaller(){
                    this.size = SMALL_SIZE;
                }

               reverseSize(){
                    if(!this.isBig()) this.makeBigger();
                    else this.makeSmaller();
               }

                getNeighbours(){
                    let neighbours = [];
                    // values to add to get neighbouring dots
                    let positionOfChildren = [[0, -1], [0, 1], [-1, 0], [1, 0]];

                    for (let i = 0; i < positionOfChildren.length; i++) {
                        // index x, y of neighbouring dots
                        let x = Dot.getIndexX(this.x) + positionOfChildren[i][0];
                        let y = Dot.getIndexY(this.y) + positionOfChildren[i][1];

                        // does this dot exist?
                        if(0 <= x && x< Dot.allDots[0].length && 0 <= y && y <  Dot.allDots.length){

                                //  Dot.nodesAreBig === true only append dots that are small
                                if (!Dot.allDots[y][x].isBig()&&!Dot.nodesAreBig) {
                                    neighbours.push(Dot.allDots[y][x])
                                }

                                // Dot.nodesAreBig === false only append dots that are big
                                if (Dot.allDots[y][x].isBig()&&Dot.nodesAreBig) {
                                    neighbours.push(Dot.allDots[y][x])
                                }
                        }

                    }
                    return neighbours
                }
                isBig(){
                    return this.size===BIG_SIZE;
                }

                static getIndexX(x){
                    return Math.round(x/DOT_DISTANCE)-1
                }

                static getIndexY(y){
                    return Math.round(y/DOT_DISTANCE)
                }

            }
            function animateAll(){
                // set this function to be update every animation frame
                requestAnimationFrame(animateAll);

                // clear canvas
                canvasWithBalls.clearRect(0,0,canvasWithBallsElement.width,canvasWithBallsElement.height);
                canvasWithDot.clearRect(0,0,canvasWithBallsElement.width,canvasWithBallsElement.height);

                // update and draw allBalls
                for (let i = 0; i < Ball.allBalls.length; i++) {
                    Ball.allBalls[i].update();
                    Ball.allBalls[i].draw();
                }

                // draw allDots
                for (let x = 0; x < Dot.allDots[0].length; x++) {
                    for (let y = 0; y < Dot.allDots.length; y++) {
                        Dot.allDots[y][x].draw();
                    }
                }

                // run Dot.showWave() a NUMBER_OF_UPDATES per a frame
                for (let i = 0; i < NUMBER_OF_UPDATES ; i++) {
                    Dot.showWave()
                }

                // set canvas color
                canvasWithDot.fillStyle = "rgba(10,5,20,0.01)";

                // redraw
                canvasWithDot.fillRect(0,0,canvasWithDotElement.width,canvasWithDotElement.height);




            }

            Ball.init()
            Dot.init();

            animateAll();


        </script>
    </body>
</html>